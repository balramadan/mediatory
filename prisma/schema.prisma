generator client {
  provider     = "prisma-client"
  output       = "../generated/prisma"
  binaryTargets = ["native", "rhel-openssl-3.0.x"]
  moduleFormat = "esm"
}

datasource db {
  provider  = "postgresql"
  url       = env("DATABASE_URL")
  directUrl = env("DIRECT_URL")
}

model users {
  user_id      String         @id @default(uuid())
  full_name    String
  email        String         @unique
  password     String
  phone        String
  createdAt    DateTime       @default(now())
  status       StatusUser     @default(inactive)
  imgUrl       String?
  transactions transactions[]
}

model admins {
  admin_id              String         @id @default(uuid())
  full_name             String
  email                 String         @unique
  password              String
  last_login            DateTime?
  createdAt             DateTime       @default(now())
  role                  RoleAdmin      @default(inventory)
  imgUrl                String?
  recorded_maintenance  maintenance[]
  return_verifications  transactions[] @relation("returnVerification")
  verified_transactions transactions[] @relation("borrowVerification")
}

model equipment {
  equipment_id       String              @id
  name               String
  quantity           Int
  createdAt          DateTime            @default(now())
  category_id        Int
  available_quantity Int
  status             StatusEquipment     @default(available)
  imgUrl             String?
  equipment_returns  ReturnDetail[]
  transactions       TransactionDetail[]
  category           categories          @relation(fields: [category_id], references: [category_id])
  maintenance        maintenance[]

  @@index([category_id])
  @@index([status])
}

model categories {
  category_id   Int         @id @default(autoincrement())
  category_name String
  description   String?
  equipment     equipment[]
}

model transactions {
  transaction_id        Int                 @id @default(autoincrement())
  user_id               String
  borrow_date           DateTime
  createdAt             DateTime            @default(now())
  admin_id              String?
  verified_at           DateTime?
  return_notes          String?
  return_verified_at    DateTime?
  return_admin_id       String?
  project               String
  purpose               String
  status                StatusTransaction   @default(pending)
  return_status         StatusReturn        @default(not_returned)
  return_date           DateTime
  return_verified_notes String?
  verified_notes        String?
  urgent                Boolean             @default(false)
  equipment_returns     ReturnDetail[]
  equipments            TransactionDetail[]
  notifications         notifications[]
  return_admin          admins?             @relation("returnVerification", fields: [return_admin_id], references: [admin_id], map: "transactions_return_verified_by_fkey")
  user                  users               @relation(fields: [user_id], references: [user_id])
  admin                 admins?             @relation("borrowVerification", fields: [admin_id], references: [admin_id], map: "transactions_verified_by_fkey")

  @@index([user_id])
  @@index([status])
  @@index([return_status])
  @@index([admin_id])
  @@index([return_admin_id])
}

model TransactionDetail {
  id             Int          @id @default(autoincrement())
  transaction_id Int
  equipment_id   String
  quantity       Int
  equipment      equipment    @relation(fields: [equipment_id], references: [equipment_id])
  transaction    transactions @relation(fields: [transaction_id], references: [transaction_id])

  @@unique([transaction_id, equipment_id])
}

model ReturnDetail {
  id                 Int             @id @default(autoincrement())
  transaction_id     Int
  equipment_id       String
  returned_quantity  Int
  condition          ConditionReturn @default(good)
  damage_notes       String?
  penalty_amount     Decimal?        @db.Decimal(10, 2) // Tambahan untuk denda
  penalty_notes      String? // Tambahan untuk catatan denda
  replacement_status String?
  equipment          equipment       @relation(fields: [equipment_id], references: [equipment_id])
  transaction        transactions    @relation(fields: [transaction_id], references: [transaction_id])
  createdAt          DateTime        @default(now())

  @@unique([transaction_id, equipment_id])
}

model maintenance {
  maintenance_id    Int               @id @default(autoincrement())
  equipment_id      String
  quantity          Int
  start_date        DateTime          @default(now())
  expected_end_date DateTime?
  actual_end_date   DateTime?
  maintenance_type  String
  description       String?
  technician_name   String?
  status            StatusMaintenance @default(ongoing)
  notes             String?
  admin_id          String?
  equipment         equipment         @relation(fields: [equipment_id], references: [equipment_id], map: "MaintenanceDetail_equipment_id_fkey")
  admin             admins?           @relation(fields: [admin_id], references: [admin_id], map: "MaintenanceDetail_recorded_by_fkey")

  @@index([equipment_id], map: "MaintenanceDetail_equipment_id_idx")
  @@index([status], map: "MaintenanceDetail_status_idx")
}

model notifications {
  notification_id String           @id @default(uuid())
  title           String
  message         String
  is_read         Boolean          @default(false)
  createdAt       DateTime         @default(now())
  transaction_id  Int?
  type            NotificationType @default(transaction)
  transaction     transactions?    @relation(fields: [transaction_id], references: [transaction_id])

  @@index([transaction_id])
  @@index([is_read])
  @@index([type])
}

enum StatusUser {
  active
  inactive
}

enum RoleAdmin {
  superadmin
  inventory
}

enum StatusEquipment {
  available
  not_available
  maintenance
}

enum StatusTransaction {
  pending
  approved
  rejected
  completed
  cancelled
  overdue
}

enum StatusReturn {
  not_returned
  pending_check
  returned_complete
  returned_damaged
  returned_incomplete
}

enum ConditionReturn {
  good
  damaged
  incomplete
  lost
  other
}

enum StatusMaintenance {
  ongoing
  completed
  cancelled
}

enum NotificationType {
  transaction
  equipment
  maintenance
  admin
  other
}
